<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>
        /*
        There are four main contexts in which the value of this can be implicitly inferred:

the global context
as a method within an object
as a constructor on a function or class
as a DOM event handler

1-In the global context, this refers to the global object. When you’re working in a browser, the global context is would be window. When you’re working in Node.js, the global context is global.
        */
        console.log(this)
        /*Output
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}*/

/*
In Understanding Variables, Scope, and Hoisting in JavaScript, you learned that functions have their own context for variables. You might be tempted to think that this would follow the same rules inside a function, but it does not. A top-level function will still retain the this reference of the global object.

You write a top-level function, or a function that is not associated with any object, like this:
*/

function printThis() {
  console.log(this)
}

printThis()
//Output
//Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
//Even within a function, this still refers to the window, or global object.

//However, when using strict mode, the context of this within a function on the global context will be undefined.
'use strict'

function printThis() {
  console.log(this)
}

printThis()
//Output undefined


//Generally, it is safer to use strict mode to reduce the probability of this having an unexpected scope. Rarely will someone want to refer to the window object using this.

/*
An Object Method
A method is a function on an object, or a task that an object can perform. A method uses this to refer to the properties of the object.
*/

const america = {
  name: 'The United States of America',
  yearFounded: 1776,

  describe() {
    console.log(`${this.name} was founded in ${this.yearFounded}.`)
  },
}

america.describe()
//Output
//"The United States of America was founded in 1776."
//In this example, this is the same as america.


//In a nested object, this refers to the current object scope of the method. In the following example, this.symbol within the details object refers to details.symbol.

const america2 = {
  name: 'The United States of America',
  yearFounded: 1776,
  details: {
    symbol: 'eagle',
    currency: 'USD',
    printDetails() {
      console.log(`The symbol is the ${this.symbol} and the currency is ${this.currency}.`)
    },
  },
}

america2.details.printDetails()
//Output
//"The symbol is the eagle and the currency is USD."
//Another way of thinking about it is that this refers to the object on the left side of the dot when calling a method.

/*
A Function Constructor
When you use the new keyword, it creates an instance of a constructor function or class. Function constructors were the standard way to initialize a user-defined object before the class syntax was introduced in the ECMAScript 2015 update to JavaScript. In Understanding Classes in JavaScript, you will learn how to create a function constructor and an equivalent class constructor.

*/

function Country(name, yearFounded) {
  this.name = name
  this.yearFounded = yearFounded

  this.describe = function() {
    console.log(`${this.name} was founded in ${this.yearFounded}.`)
  }
}

const america3 = new Country('The United States of America', 1776)

america3.describe()
//Output
//"The United States of America was founded in 1776."
//In this context, this is now bound to the instance of Country, which is contained in the america constant.

/*
A Class Constructor
A constructor on a class acts the same as a constructor on a function. Read more about the similarities and differences between function constructors and ES6 classes in Understanding Classes in JavaScript.
*/

class Country {
  constructor(name, yearFounded) {
    this.name = name
    this.yearFounded = yearFounded
  }

  describe() {
    console.log(`${this.name} was founded in ${this.yearFounded}.`)
  }
}

const america4 = new Country('The United States of America', 1776)

america4.describe()
//this in the describe method refers to the instance of Country, which is america.
//Output
//"The United States of America was founded in 1776."

/*
A DOM Event Handler
In the browser, there is a special this context for event handlers. In an event handler called by addEventListener, this will refer to event.currentTarget. More often than not, developers will simply use event.target or event.currentTarget as needed to access elements in the DOM, but since the this reference changes in this context, it is important to know.

In the following example, we’ll create a button, add text to it, and append it to the DOM. When we log the value of this within the event handler, it will print the target.
*/

const button = document.createElement('button')
button.textContent = 'Click me'
document.body.append(button)

button.addEventListener('click', function(event) {
  console.log(this)
})
//Output
//<button>Click me</button>
/*
Once you paste this into your browser, you will see a button appended to the page that says “Click me”. If you click the button, you will see <button>Click me</button> appear in your console, as clicking the button logs the element, which is the button itself. Therefore, as you can see, this refers to the targeted element, which is the element we added an event listener to.
*/

/*
Call and Apply
call and apply are very similar—they invoke a function with a specified this context, and optional arguments. The only difference between call and apply is that call requires the arguments to be passed in one-by-one, and apply takes the arguments as an array.

In this example, we’ll create an object, and create a function that references this but has no this context.

*/

const book = {
  title: 'Brave New World',
  author: 'Aldous Huxley',
}

function summary() {
  console.log(`${this.title} was written by ${this.author}.`)
}

summary()

//Output
//"undefined was written by undefined"

//However, you can use call and apply to invoke the this context of book on the function.
summary.call(book)
// or:
summary.apply(book)
//This is how call and apply are the same, but there is one small difference. In addition to being able to pass the this context as the first argument, you can also pass additional arguments through.

function longerSummary(genre, year) {
  console.log(
    `${this.title} was written by ${this.author}. It is a ${genre} novel written in ${year}.`
  )
}

longerSummary.call(book, 'dystopian', 1932)
//Output
//"Brave New World was written by Aldous Huxley. It is a dystopian novel written in 1932."

//Instead, for apply, you have to pass all the arguments in an array.
longerSummary.apply(book, ['dystopian', 1932])
//Output
//"Brave New World was written by Aldous Huxley. It is a dystopian novel written in 1932."
//The difference between passing the arguments individually or in an array is subtle, but it’s important to be aware of. It might be simpler and more convenient to use apply, as it would not require changing the function call if some parameter details changed.


// Bind
// Both call and apply are one-time use methods—if you call the method with the this context it will have it, but the original function will remain unchanged.

// Sometimes, you might need to use a method over and over with the this context of another object, and in that case you could use the bind method to create a brand new function with an explicitly bound this.
const braveNewWorldSummary = summary.bind(book)

braveNewWorldSummary()
//Output
//"Brave New World was written by Aldous Huxley"


//In this example, every time you call braveNewWorldSummary, it will always return the original this value bound to it. Attempting to bind a new this context to it will fail, so you can always trust a bound function to return the this value you expect.

//MUTHIS ONEMLI BIR ORNEK-BIND ILE BIR FONKSIYONU BIR OBJEYE THISINE BAGLADIGMIZ ZAMAN ARTIK ONUN DEGISMEYECEGINE GUVENEBILIRIZ....
const braveNewWorldSummary2 = summary.bind(book)

braveNewWorldSummary() // Brave New World was written by Aldous Huxley.

const book2 = {
  title: '1984',
  author: 'George Orwell',
}

braveNewWorldSummary2.bind(book2)

braveNewWorldSummary2() // Brave New World was written by Aldous Huxley.

//Although this example tries to bind braveNewWorldSummary once again, it retains the original this context from the first time it was bound.

//Arrow Functions
// Arrow functions do not have their own this binding. Instead, they go up to the next level of execution.

const whoAmI = {
  name: 'Leslie Knope',
  regularFunction: function() {
    console.log(this.name)
  },
  arrowFunction: () => {//this angir window
    console.log(this.name)
  },
}

whoAmI.regularFunction() // "Leslie Knope"
whoAmI.arrowFunction() // undefined

/*
It can be useful to use the arrow function in cases where you really want this to refer to the outer context. For example, if you had an event listener inside of a class, you would probably want this to refer to some value in the class.

In this example, you’ll create and append button to the DOM like before, but the class will have an event listener that will change the text value of the button when clicked.
*/

//ARROW FUNCTION KULLANARAK KARSILASILABILECEK PROBLEMDEN KURTULMAK

const button = document.createElement('button')
button.textContent = 'Click me'
document.body.append(button)

class Display {
  constructor() {
    this.buttonText = 'New text'

    button.addEventListener('click', event => {
      event.target.textContent = this.buttonText
    })
  }
}

new Display()

//If you click the button, the text content will change to the value of buttonText. If you hadn’t used an arrow function here, this would be equal to event.currentTarget, and you wouldn’t be able to use it to access a value within the class without explicitly binding it. This tactic is often used on class methods in frameworks like React.
</script>
</body>
</html>